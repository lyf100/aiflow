# Feature Specification: AI分析指挥与可视化平台 - 层级行为沙盘系统

**Feature Branch**: `001-ai`
**Created**: 2025-10-09
**Status**: Draft
**Input**: 我们构建的是一个"AI分析指挥与可视化平台"(MCP Tool)，它将代码的层级化静态结构与层级化动态行为融合成一个统一的、可交互的"行为沙盘"。平台通过AI适配器连接外部AI编程工具，使用核心指令集指挥AI进行全面代码分析，生成标准化JSON数据，并通过可视化引擎渲染成交互式的层级结构图。用户可通过点击AI命名的启动按钮观察宏观和微观的代码执行行为，支持钻取到单步运行详情视图进行深度分析。

## User Scenarios & Testing *(mandatory)*

### User Story 1 - AI驱动的代码结构分析与可视化 (Priority: P1)

**用户场景**: 开发者需要快速理解一个陌生的代码项目结构。他们希望通过连接AI工具来自动分析整个代码库，并查看AI生成的层级化、业务语义化的代码结构图。

**Why this priority**: 这是平台的核心价值所在 - 提供AI驱动的代码理解能力。没有这个基础功能，其他所有功能都无法实现。它解决了开发者最痛的需求：理解复杂代码库的整体架构和模块关系。

**Independent Test**: 可通过以下方式独立测试：用户提供一个代码项目路径，选择一个AI工具，点击"开始分析"，系统返回一个可交互的、带有业务语义标签的层级结构图。验证图中节点、分组、连接关系是否正确反映代码结构。

**Acceptance Scenarios**:

1. **Given** 用户已选择一个代码项目和可用的AI工具，**When** 用户点击"开始分析"按钮，**Then** 系统向AI发送分阶段分析指令，AI返回包含项目认知、静态结构、层级划分、功能命名的JSON数据，系统成功渲染出代码整体结构图
2. **Given** 分析完成后显示结构图，**When** 用户查看图中的节点和分组，**Then** 每个节点和分组都有AI生成的业务语义化名称（如"用户认证模块"而非"AuthController"），并使用颜色、标签、Logo标识架构模式和技术栈
3. **Given** 结构图中有多层级的分组块，**When** 用户双击一个分组块，**Then** 该分组块展开显示内部的子组件和子模块，面包屑导航显示当前层级路径
4. **Given** 结构图已渲染完成，**When** 用户缩放或平移画布，**Then** 系统流畅响应（层级切换<300ms），支持自由探索大型代码结构
5. **Given** 用户正在查看某个特定层级，**When** 用户点击面包屑导航中的上级路径，**Then** 系统平滑返回到上级层级视图

---

### User Story 2 - 宏观流程联动可视化 (Priority: P2)

**用户场景**: 开发者需要理解一个大型功能模块（如"订单处理系统"）的完整执行流程。他们希望点击该模块的"大按钮"，观察系统如何协调多个子模块（验证库存、计算价格、扣减库存、生成订单）进行联动执行，并通过动画清晰展示数据流和控制流。

**Why this priority**: 这是平台的核心交互能力 - 将静态结构图变为动态行为沙盘。它解决了"理解代码如何协同运行"的关键需求，是连接结构理解与行为理解的桥梁。

**Independent Test**: 可通过以下方式独立测试：在已生成的结构图上，点击一个大模块的启动按钮（如"处理订单"），系统播放多流程联动动画，显示各子模块的激活顺序、数据传递、同步点。验证动画是否准确反映代码的执行逻辑。

**Acceptance Scenarios**:

1. **Given** 用户已查看代码结构图并识别到一个大模块（如"订单处理系统"），**When** 用户点击该模块上的AI命名的启动按钮（如"处理用户订单"），**Then** 系统启动宏观联动动画，依次高亮激活"验证库存"、"计算价格"、"扣减库存"、"生成订单"等子模块，使用不同颜色的流动箭头表示数据流和控制流
2. **Given** 宏观联动动画正在播放，**When** 用户观察动画过程，**Then** 系统清晰展示子流程的执行顺序、并行分支、同步等待点（如库存验证完成后才计算价格），并在右侧显示当前执行状态和关键变量值
3. **Given** 联动动画涉及多个并发流程（如同时查询库存和用户积分），**When** 系统播放并发部分，**Then** 多个流程使用不同颜色的动画指示器同步移动，清晰区分并行执行、异步调用和同步等待，并在汇合点显示同步栅栏标识
4. **Given** 用户正在观察宏观联动动画，**When** 用户想暂停或回溯查看某个关键步骤，**Then** 系统提供播放控制器（播放/暂停、快进/后退、速度调节），支持任意时刻暂停并钻入子模块查看详细执行
5. **Given** 宏观联动动画完成后，**When** 用户查看动画总结面板，**Then** 系统显示完整的执行路径图、涉及的子模块列表、总执行时间、关键状态变化，并提供保存为"执行书签"的选项

---

### User Story 3 - 微观子流程独立执行 (Priority: P3)

**用户场景**: 开发者需要深入理解某个子模块（如"计算订单价格"）的内部逻辑。他们希望展开该子模块，看到其内部的更细粒度组件（如"获取商品价格"、"应用折扣"、"计算税费"），并点击子模块的"小按钮"独立启动其执行流程，而不触发整个大流程。

**Why this priority**: 这是平台的深度探索能力 - 支持在任意抽象层次启动和观察执行。它解决了"我只想理解这一小部分代码如何工作"的需求，允许开发者聚焦关注点而不被大流程干扰。

**Independent Test**: 可通过以下方式独立测试：在结构图中双击展开一个大模块，看到其内部的子模块和各自的启动按钮，点击某个子模块的小按钮（如"应用折扣规则"），系统独立播放该子流程的执行动画。验证子流程动画是否独立于大流程、是否正确展示内部逻辑。

**Acceptance Scenarios**:

1. **Given** 用户已展开一个大模块（如"订单处理系统"）并看到内部的子模块，**When** 用户点击某个子模块的启动按钮（如"计算订单价格"），**Then** 系统独立启动该子流程的执行动画，仅高亮该子模块内部的组件（获取价格、应用折扣、计算税费），不激活其他兄弟子模块
2. **Given** 子流程独立执行动画正在播放，**When** 用户观察动画，**Then** 系统显示该子流程的孤立模式视图（仅该子模块）和上下文模式视图（显示上级调用链），用户可在两种视图间切换，理解子流程的独立行为和在大流程中的角色
3. **Given** 子流程涉及嵌套调用（如"应用折扣"内部调用"查询用户会员等级"），**When** 系统播放嵌套调用部分，**Then** 动画展示调用关系和参数传递，用户可进一步钻入更深层级查看"查询用户会员等级"的执行细节，支持任意深度嵌套
4. **Given** 用户正在观察子流程执行动画，**When** 用户想向上追溯完整调用链，**Then** 系统提供"向上追溯"按钮，点击后显示从最顶层入口到当前子流程的完整调用路径，并高亮当前子流程在整体流程中的位置
5. **Given** 子流程执行完成，**When** 用户查看子流程执行总结，**Then** 系统显示该子流程的输入参数、输出结果、内部状态变化、调用的下级函数列表，并提供"在大流程中查看"选项，点击后返回宏观视图并定位到该子流程

---

### User Story 4 - 单步运行详情视图深度分析 (Priority: P4)

**用户场景**: 开发者在观察宏观或微观执行动画时，发现某个关键步骤需要深入分析（如"为什么这里的折扣计算结果不对"）。他们希望在动画暂停时点击该步骤，进入"单步运行详情"视图，查看当前代码行、所有变量值、调用栈、内存快照，并逐行单步执行、检查和修改变量、设置断点。

**Why this priority**: 这是平台的终极深度能力 - 提供传统调试器级别的细节检查。它解决了"从宏观理解到微观调试"的最后一公里，使平台成为完整的代码理解与调试工具。作为P4优先级，它是高级特性，依赖于前三个核心功能。

**Independent Test**: 可通过以下方式独立测试：在任意执行动画中暂停并点击当前激活的代码单元，系统打开单步详情视图，显示Monaco编辑器中的当前代码行、变量面板、调用栈面板、内存快照面板。使用Step Into/Over/Out按钮单步执行，验证变量值实时更新、调用栈变化、与主结构图的双向同步。

**Acceptance Scenarios**:

1. **Given** 用户正在观察宏观或微观执行动画并暂停在某个关键步骤，**When** 用户点击当前高亮的代码单元，**Then** 系统打开"单步运行详情"视图，使用Monaco编辑器显示当前代码行（语法高亮），在右侧面板显示当前作用域内的所有变量及其值（支持展开对象、数组），底部显示完整的调用栈
2. **Given** 单步详情视图已打开，**When** 用户点击"Step Into"按钮，**Then** 系统执行当前代码行并进入函数内部（如果是函数调用），Monaco编辑器跳转到被调用函数的第一行，变量面板更新为新作用域的变量，调用栈增加一层，主结构图同步高亮当前执行位置
3. **Given** 单步详情视图显示当前变量值，**When** 用户点击某个变量进行检查和修改（用于假设分析），**Then** 系统展开该变量的完整结构（对象属性、数组元素），允许用户编辑变量值，修改后点击"应用"，后续单步执行使用修改后的值，系统标记这是"假设分析模式"
4. **Given** 用户想在特定条件下暂停执行，**When** 用户右键点击某行代码并选择"设置条件断点"，输入条件表达式（如"discount < 0.5"），**Then** 系统在该行设置条件断点标识（红点），当单步执行到该行且条件满足时自动暂停，显示当前变量值和条件表达式结果
5. **Given** 用户想查看某个变量的历史变化轨迹，**When** 用户在变量面板中右键点击变量并选择"查看历史"，**Then** 系统显示该变量在整个执行过程中的值变化时间线（变化时刻、旧值、新值、修改位置），用户可点击任意时刻跳转到对应的执行点
6. **Given** 单步详情视图显示内存快照，**When** 用户切换到"内存视图"标签，**Then** 系统显示当前堆栈内存状态（对象分配、引用关系、内存占用），支持可视化呈现对象引用图，帮助理解复杂数据结构和潜在内存泄漏
7. **Given** 用户在单步详情视图中步进执行，**When** 主结构图中的执行位置发生变化（跨模块调用），**Then** 主结构图实时同步高亮当前执行位置，如果跨层级则自动展开对应的分组块，反之，用户在主结构图中点击跳转时，单步详情视图立即定位到对应代码行

### Edge Cases

- **当AI分析返回不完整或格式错误的JSON数据时**，系统应尽力解析可用部分并生成部分结构图，标注缺失区域，提供重新分析选项而非完全失败
- **当代码项目规模超大（>10000个节点）时**，系统应启用虚拟化渲染和分页加载策略，初始仅渲染可见区域（<2秒），支持按需加载详细信息，避免浏览器崩溃
- **当用户选择的AI工具连接失败或超时时**，系统应提供清晰的错误提示（连接状态、错误原因、重试选项），支持切换到其他可用AI工具，或使用离线模式加载预生成的分析结果文件
- **当并发流超过系统可视化能力上限（>10个并发流）时**，系统应自动降级到简化视图（显示并发流数量和汇合点，不展示每个流的详细动画），或提供"聚焦模式"让用户选择关注的并发流子集
- **当用户在单步详情视图中修改变量后继续执行导致代码崩溃时**，系统应捕获异常并标记为"假设分析异常"，允许用户回退到修改前状态或重置为原始执行路径，保护原始分析数据不被破坏
- **当代码包含不支持的语言特性或框架（如内联汇编、特定平台API）时**，AI可能无法完全理解语义，系统应标注不确定区域（虚线边框、问号图标），提供"人工标注"功能让用户补充说明
- **当用户频繁展开/折叠层级导致动画卡顿时**，系统应自动检测性能瓶颈（帧率<15 FPS），建议用户启用"性能模式"（减少动画效果、使用静态图标），或提供"快照模式"（冻结当前视图状态，暂停实时渲染）
- **当用户在宏观动画播放时钻入子模块详情，再返回宏观视图时**，系统应保持原动画的时间点和执行状态同步，而非从头重新播放，确保用户不会迷失在层级跳转中
- **当代码存在递归调用或循环依赖时**，结构图可能出现环形引用，系统应使用特殊视觉标识（环形箭头、折叠节点）表示递归关系，执行动画时限制递归展示深度（如显示前3层递归），避免无限循环渲染
- **当用户设置断点或时间回溯到某个状态点，但该状态点的上下文信息不完整时**，系统应使用"近似状态"标识（橙色边框、提示信息），说明状态快照的局限性（如某些变量值基于推断而非实际记录），避免误导用户


## Clarifications

### Session 2025-10-09

- Q: 什么是"标准数据协议"的详细结构定义? → A: 标准数据协议是整个平台的核心契约，是一份严格定义的JSON格式，包含以下完整结构：

#### 层级结构 (for Cytoscape.js)
- 节点间的父子关系定义 (parent 属性)
- 用于视觉渲染的 classes, stereotype 等属性
- 支持多层级嵌套和动态展开/折叠

#### 可执行单元 (Traceable Unit)
每个可执行单元对象包含：
- id: 对应结构图中的节点ID
- name: 由AI生成的、有意义的功能名称
- type: "single-trace" (单线程) 或 "multi-trace" (多线程联动)
- subUnitIds: 可选数组，定义行为的父子组合关系
- traces: 描述其行为的一个或多个流程轨迹

#### 轨迹细节 (for D3.js)
traces 对象内部支持多种格式：

**流程图格式**:
- steps 列表：每个step有 id, label, type 等
- connections 列表：定义步骤间的连接关系
- type 需支持 fork 和 join 以表达并发分叉和汇合

**时序图格式**:
- lifelines 列表：表示参与的执行实体（线程、服务、组件）
- messages 列表：每个message有 source, target, type（同步/异步）等

**变量范围与状态**:
在单步轨迹中，需要专门的结构来描述：
- 不同作用域（全局、局部）
- 每一步的变量状态快照
- 作用域嵌套关系

**递归展示方式**:
在"单步运行详情"视图中，通过调用堆栈的可视化（层层嵌套的区块）来清晰展示递归关系。

## Requirements *(mandatory)*

### Functional Requirements

#### AI 集成与调度 (AI Integration & Orchestration)

- **FR-001**: 系统 MUST 通过标准化适配器接口 (Adapter Interface) 接入并消费来自多种 AI 编程工具的分析结果（IDE 集成 AI 工具、命令行 AI 工具、云端 AI 服务、本地 AI 模型）
- **FR-002**: 系统 MUST 内置一套精心设计的核心指令集（Prompt Templates），用于驱动外部 AI 工具进行代码分析，指令集必须版本化管理并支持根据不同语言、框架定制
- **FR-003**: 系统 MUST 作为"指挥官"角色，主动地、分阶段地调度 AI 编程工具完成分析任务（结构识别 → 功能语义分析 → 执行流程推理 → 并发模式识别）
- **FR-004**: 系统 MUST 采用最高效的策略进行 AI 调度（先整体后局部、先结构后细节、并行分析等），并记录每次 AI 调用的输入输出、耗时、token 消耗
- **FR-005**: 系统 MUST 对 AI 返回的分析结果进行格式验证、完整性检查和一致性校验，对不满足要求的结果自动生成精炼 Prompt 要求 AI 重新分析
- **FR-006**: 适配器 MUST 支持可插拔架构，允许动态添加新的 AI 工具分析源。当适配器故障或 AI 分析失败/超时时，系统 MUST 实施优雅降级策略以确保核心可视化功能不受影响：
  - **Level 1 (完整功能)**: 主适配器正常工作，所有 AI 分析功能可用，完整的结构识别、语义分析和执行推理
  - **Level 2 (备用适配器)**: 主适配器失败时自动切换到备用适配器（如果配置），保持完整功能但可能有性能差异
  - **Level 3 (缓存模式)**: 所有适配器不可用时，使用最近的分析缓存结果（基于项目哈希匹配），显示"缓存数据"标识和缓存时间，用户可查看但无法触发新分析
  - **Level 4 (部分分析)**: AI 分析超时或返回不完整数据时，系统尽力解析可用部分，生成部分结构图并标注缺失区域（虚线边框、问号图标），提供"重试"和"补充分析"选项
  - **Level 5 (离线模式)**: 用户可手动加载预生成的分析结果文件（标准 JSON 格式），完全离线运行可视化功能，适用于无网络环境或 CI/CD 集成场景
  - **用户通知策略**: 降级时通过非阻塞通知栏显示当前状态（适配器不可用、使用缓存数据、部分分析完成），提供明确的操作建议（重试、切换适配器、加载离线文件）和错误详情（连接状态、错误原因、预计恢复时间）
- **FR-007**: 系统 MUST 支持"分析缓存"机制，相同代码的 AI 分析结果可复用（LRU 淘汰策略），缓存命中率 ≥70%
- **FR-008**: 系统 MUST 支持"增量分析"机制，代码变更时仅对变更部分驱动 AI 重新分析（智能范围限定 + 缓存复用）
- **FR-009**: 系统 MUST 支持离线模式，可基于预生成的 AI 分析结果文件独立运行，不依赖外部 AI 工具连接

#### 标准化数据协议 (Standardized Data Protocol)

- **FR-010**: 系统 MUST 定义并实现标准化数据格式规范（JSON Schema），数据格式必须版本化并确保向后兼容至少 2 个 MAJOR 版本
- **FR-011**: 标准化数据格式 MUST 包含 code_structure 字段，该字段定义 Cytoscape.js 所需的层级结构，包括：节点列表（每个节点包含 id, label, parent, classes, stereotype 等属性）、节点间父子关系（通过 parent 属性定义）、逻辑分组元数据、功能单元标识
- **FR-012**: 标准化数据格式 MUST 包含 behavior_metadata 字段（启动按钮命名、功能描述、执行场景定义）
- **FR-013**: 标准化数据格式 MUST 包含 execution_trace 字段，该字段定义所有可执行单元（Traceable Unit）的轨迹数据，每个可执行单元对象包含：id（对应结构图节点ID）、name（AI生成的功能名称）、type（single-trace 或 multi-trace）、subUnitIds（子单元ID数组，定义行为父子关系）、traces（流程轨迹数组，支持流程图格式、时序图格式、变量状态快照）
- **FR-014**: 标准化数据格式 MUST 包含 concurrency_info 字段（并发流识别、同步点、依赖关系）
- **FR-015**: 标准化数据格式 MUST 包含 prompt_templates 字段（AI 驱动的核心指令集模板）
- **FR-016**: 每个 AI 决策（功能识别、命名、分组）MUST 附带解释信息和置信度，支持可解释性和透明度
- **FR-016a**: execution_trace 中的 traces 对象 MUST 支持流程图格式，包含 steps 列表（每个step有 id, label, type, data等字段）和 connections 列表（source, target, label等字段），type字段必须支持 fork（并发分叉）和 join（并发汇合）类型
- **FR-016b**: execution_trace 中的 traces 对象 MUST 支持时序图格式，包含 lifelines 列表（表示参与的执行实体：线程、服务、组件）和 messages 列表（每个message有 source, target, type[同步/异步], timestamp, label等字段）
- **FR-016c**: execution_trace 中的单步轨迹 MUST 包含 variableScopes 结构，描述不同作用域（global、local、closure等）及其内部变量在每一步的状态快照（变量名、类型、值、内存地址、引用关系）
- **FR-016d**: 递归调用场景下，execution_trace MUST 在调用栈结构中记录递归深度、每层递归的参数值和返回值，支持在"单步运行详情"视图中通过层层嵌套的可视化区块展示递归关系
- **FR-016e**: 所有 traces 数据 MUST 包含时间戳（timestamp）、执行顺序（executionOrder）、持续时间（duration）等时间序列信息，支持时间回溯和播放控制功能

#### 层级化代码结构可视化 (Hierarchical Code Structure Visualization)

- **FR-017**: 系统 MUST 使用图形渲染引擎（Cytoscape.js 用于大型图、D3.js 用于力导向图）渲染交互式的层级化代码结构图
- **FR-018**: 系统 MUST 支持至少 3 个抽象层次（系统级 → 模块级 → 函数级），AI 基于代码语义自动识别逻辑分组
- **FR-019**: 图上每一个由 AI 识别出的、具备独立业务功能的代码单元 MUST 附带一个专属的启动按钮，按钮名称由 AI 根据功能目的自动生成（自然语言描述）
- **FR-020**: 用户 MUST 能够自由展开/折叠任意层级（双击节点展开下一层级、显示内部组件和子模块），层级转换必须保持视觉连贯性
- **FR-021**: 系统 MUST 提供面包屑导航显示当前所在层级路径，支持点击上级路径快速返回
- **FR-022**: 系统 MUST 支持缩放/平移操作，流畅响应大型代码结构的自由探索（层级切换 <300ms）
- **FR-023**: 每个节点和分组 MUST 有 AI 生成的业务语义化名称（如"用户认证模块"而非"AuthController"），并使用颜色、标签、Logo 标识架构模式和技术栈

#### 行为驱动交互与启动按钮 (Behavior-Driven Interaction & Launch Buttons)

- **FR-024**: 启动按钮本身 MUST 存在层级关系，"大模块"上的"大按钮"可启动宏观联动场景，展开后内部的子模块拥有各自的"小按钮"可独立启动子流程
- **FR-025**: 大模块的启动按钮 MUST 能够触发涉及多个子流程的宏观联动执行场景，系统自动协调并可视化所有涉及的子流程联动
- **FR-026**: 子模块的启动按钮 MUST 能够独立触发其自身的子流程执行（孤立模式：仅该子模块；上下文模式：显示上级调用链）
- **FR-027**: 系统 MUST 支持任意深度的行为嵌套（受限于代码实际层级），用户在宏观执行过程中可"钻入"特定子模块查看内部详细执行
- **FR-028**: 从子模块视角启动时，系统 MUST 提供"向上追溯"功能，显示从最顶层入口到当前子流程的完整调用链
- **FR-029**: 执行状态 MUST 在所有层级间保持一致和同步，系统提供视觉指示器标识当前执行所处的层级深度

#### 宏观流程联动动画 (Macro Process Linkage Animation)

- **FR-030**: 系统 MUST 支持宏观联动动画，依次高亮激活涉及的子模块，使用不同颜色的流动箭头表示数据流和控制流
- **FR-031**: 动画 MUST 清晰展示子流程的执行顺序、并行分支、同步等待点（如依赖关系），在右侧显示当前执行状态和关键变量值
- **FR-032**: 系统 MUST 提供播放控制器（播放/暂停、快进/后退、速度调节 0.1x-10x），支持任意时刻暂停并钻入子模块查看详细执行
- **FR-033**: 宏观联动动画完成后 MUST 显示完整的执行路径图、涉及的子模块列表、总执行时间、关键状态变化，并提供保存为"执行书签"的功能
- **FR-034**: 用户在宏观动画播放时钻入子模块详情再返回时，系统 MUST 保持原动画的时间点和执行状态同步，而非从头重新播放

#### 并发行为可视化 (Concurrency Visualization)

- **FR-035**: 系统 MUST 提供时序图 (Sequence Diagram) 视图，清晰展示不同执行线程/协程的时间先后关系（垂直轴表示时间推进）
- **FR-036**: 系统 MUST 提供带分叉/汇合的流程图，精确表达并行分支、同步点、Join 操作（使用并行网关 Fork/Join 表示）
- **FR-037**: 系统 MUST 在主结构图上通过多流程联动动画实时展示并发执行的多个代码单元，使用不同颜色或标识区分不同的执行流
- **FR-038**: 系统 MUST 区分并可视化：并行 (Parallel)、并发 (Concurrent)、异步 (Async)、同步等待 (Sync Wait) 四种并发语义
- **FR-039**: 多个流程同时执行时 MUST 在相应的代码单元上显示多个活动指示器，流程在不同层级间跳转时动画保持连贯性
- **FR-040**: 系统 MUST 提供"暂停全部"和"暂停单个流"的控制，支持"单流聚焦"模式（暂时隐藏其他并发流）
- **FR-041**: 并发流数量支持：流畅支持 ≤5 个并发流（≥30 FPS），降级支持 ≤10 个（≥15 FPS），超过 10 个自动降级到简化视图

#### 单步运行详情视图 (Step-by-Step Detail View)

- **FR-042**: 用户 MUST 能够在任何时刻从"主结构图"钻取进入"单步运行详情"视图（点击当前高亮的代码单元）
- **FR-043**: 单步详情视图 MUST 使用 Monaco Editor（VS Code 内核）显示当前代码行的源代码和语法高亮
- **FR-044**: 单步详情视图 MUST 在右侧面板显示当前作用域内的所有变量及其值（支持展开对象、数组、树、图结构）
- **FR-045**: 单步详情视图 MUST 在底部显示完整的调用栈（函数调用链）和返回路径
- **FR-046**: 单步详情视图 MUST 支持内存状态快照（对象分配、引用关系、内存占用、对象引用图可视化）
- **FR-047**: 用户 MUST 能够逐行单步执行（Step Into / Step Over / Step Out），Monaco 编辑器跳转到对应代码行，变量面板实时更新
- **FR-048**: 用户 MUST 能够检查和修改变量值（用于假设分析），修改后系统标记为"假设分析模式"，后续执行使用修改后的值
- **FR-049**: 用户 MUST 能够查看变量的历史变化轨迹（变化时刻、旧值、新值、修改位置），点击任意时刻跳转到对应的执行点
- **FR-050**: 用户 MUST 能够设置条件断点（变量值满足条件时暂停），系统在满足条件时自动暂停并显示当前变量值和条件表达式结果
- **FR-051**: 单步详情视图与主结构图 MUST 保持双向同步（详情视图步进时主结构图同步高亮，主结构图跳转时详情视图立即定位）
- **FR-052**: 用户 MUST 能够创建"执行书签"（保存特定的执行状态和视角），便于重复访问和对比分析

#### 性能与质量标准 (Performance & Quality Standards)

- **FR-053**: 小型项目 (<500 节点)：首次渲染 <1 秒，层级切换 <150ms
- **FR-054**: 中型项目 (500-2000 节点)：首次渲染 <3 秒，层级切换 <300ms
- **FR-055**: 大型项目 (2000-5000 节点)：首次渲染 <8 秒，层级切换 <500ms
- **FR-056**: 超大项目 (>5000 节点)：支持渐进式加载和虚拟化渲染，初始可见区域 <2 秒
- **FR-057**: AI 分析性能（深度语义分析需要充足时间）：小型项目 (<1000 LOC) 完整分析 2-5 分钟，中型项目 (1000-5000 LOC) 10-20 分钟，大型项目 (5000-20000 LOC) 30-60 分钟，超大项目 (>20000 LOC) 1-3 小时，支持断点续传和进度可视化

### Key Entities *(include if feature involves data)*

- **AIAdapter**: AI 适配器实体，表示与外部 AI 工具的连接适配器（适配器类型、连接配置、API 端点、认证信息、状态监控）
- **PromptTemplate**: 核心指令集模板实体，表示用于驱动 AI 分析的 Prompt 模板（模板 ID、版本号、目标语言、分析阶段、输入格式、输出格式、质量标准、示例）
- **CodeStructure**: 代码结构实体，表示 AI 分析返回的层级化代码结构（节点列表、分组信息、层级关系、依赖关系、架构模式标识）
- **FunctionalUnit**: 功能单元实体，表示具备独立业务功能的代码单元（单元 ID、AI 生成名称、业务语义描述、代码位置、所属模块、启动按钮配置）
- **ExecutionTrace**: 执行追踪实体，表示代码执行过程的追踪数据（执行路径、状态快照序列、时间戳、变量值、调用栈、内存快照）
- **ConcurrencyFlow**: 并发流实体，表示并发执行的流程（流 ID、流类型（并行/并发/异步/同步）、涉及的代码单元、同步点、依赖关系）
- **LaunchButton**: 启动按钮实体，表示附加在功能单元上的启动按钮（按钮 ID、AI 命名、按钮类型（大按钮/小按钮）、触发场景、关联的功能单元）
- **AnimationScene**: 动画场景实体，表示执行动画的场景配置（场景类型（宏观/微观）、涉及的流程、动画时长、播放控制配置）
- **StepDetailView**: 单步详情视图实体，表示单步运行详情的视图状态（当前代码行、变量快照、调用栈、内存快照、断点配置、历史记录）
- **AnalysisCache**: 分析缓存实体，表示 AI 分析结果的缓存（缓存 ID、项目哈希、分析结果、缓存时间、LRU 优先级）

## Success Criteria *(mandatory)*

### Measurable Outcomes

#### AI 分析质量指标 (AI Analysis Quality Metrics)

- **SC-001**: AI 识别的独立功能单元与人类专家评估一致性 ≥85%（通过对比测试验证）
- **SC-002**: 自动生成的启动按钮名称清晰度和业务相关性评分 ≥4.0/5.0（用户主观评分）
- **SC-003**: AI 生成的模块分组与代码逻辑内聚性的相关度 ≥0.8（统计指标验证）
- **SC-004**: 并发模式识别的召回率 ≥90%，精确率 ≥85%（针对已知并发模式的测试集）
- **SC-005**: 核心指令集在主流 AI 模型上的稳定表现率 ≥95%（重复执行结果一致性验证）

#### 可视化性能指标 (Visualization Performance Metrics)

- **SC-006**: 小型项目 (<500 节点) 首次渲染时间 <1 秒达成率 ≥95%
- **SC-007**: 中型项目 (500-2000 节点) 首次渲染时间 <3 秒达成率 ≥90%
- **SC-008**: 大型项目 (2000-5000 节点) 首次渲染时间 <8 秒达成率 ≥85%
- **SC-009**: 层级切换响应时间 P95 <300ms，P99 <500ms（中型项目基准）
- **SC-010**: 动画帧率在 ≤5 个并发流时 ≥30 FPS 达成率 ≥95%

#### 交互体验指标 (Interaction Experience Metrics)

- **SC-011**: 新用户能在 15 分钟内掌握基本交互（层级导航、启动按钮、播放控制、详情视图钻取）的比例 ≥90%
- **SC-012**: 用户成功完成"理解陌生代码项目结构"任务的首次成功率 ≥85%
- **SC-013**: 用户在宏观动画播放中成功钻入子模块查看详情的操作成功率 ≥95%
- **SC-014**: 用户在单步详情视图中成功设置断点和查看变量历史的操作成功率 ≥90%
- **SC-015**: 用户对"层级切换流畅性"的满意度评分 ≥4.0/5.0

#### 系统可靠性指标 (System Reliability Metrics)

- **SC-016**: AI 工具连接失败时系统能够优雅降级（提供离线模式或缓存结果）的成功率 ≥98%
- **SC-017**: 超大项目 (>5000 节点) 渲染时系统不崩溃的成功率 ≥99%
- **SC-018**: 并发流超过 10 个时系统自动降级到简化视图的成功率 ≥100%
- **SC-019**: 用户在假设分析模式中修改变量导致崩溃时系统成功捕获异常并允许回退的成功率 ≥100%
- **SC-020**: AI 分析缓存命中率 ≥70%，结构图数据缓存命中率 ≥80%

#### 功能完整性指标 (Feature Completeness Metrics)

- **SC-021**: 支持的 AI 工具类型数量 ≥4（IDE 集成、命令行、云端、本地）
- **SC-022**: 支持的编程语言数量 ≥3（优先支持 Python, JavaScript/TypeScript, Java，后续扩展 Go, Rust）
- **SC-023**: 单步详情视图功能覆盖率 ≥90%（包括变量检查、调用栈、内存快照、断点、历史轨迹、假设分析）
