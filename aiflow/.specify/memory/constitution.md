<!--
Sync Impact Report
==================
Version Change: 2.0.0 → 2.1.0
Modified Principles:
  - Principle I: "Open Connectivity" → renumbered to Principle II (no content change)
  - Principle II-V: All renumbered to III-VI (no content changes except principle V)
  - Principle VI (former V): "User Complete Control" → expanded with "Step-by-Step Execution Detail View" capability
Added Sections:
  - Principle I: AI Command-Driven Strategy (Strategy Core) - NEW
  - Enhanced Principle VI with step-by-step detail view drilling capability
Removed Sections: None
Templates Requiring Updates:
  ✅ .specify/templates/plan-template.md - Constitution Check section present
  ✅ .specify/templates/spec-template.md - User scenario structure compatible
  ✅ .specify/templates/tasks-template.md - Task organization supports principles
Follow-up TODOs: None
Rationale: MINOR version bump due to addition of new core principle (AI Command-Driven Strategy) and material expansion of user control capabilities. No breaking changes to existing principles or data formats.
-->

# AIFlow Constitution

## Core Principles

### I. AI Command-Driven Strategy (Strategy Core) - MANDATORY

本工具的核心智慧在于其内置的"核心指令集 (Prompts)"。它不自行解析代码，而是作为指挥官，主动地、分阶段地驱使 AI 编程工具，以最高效的策略完成所有分析工作。

**核心要求**：
- 系统 MUST 内置一套精心设计的核心指令集（Prompt Templates），用于驱动外部 AI 工具进行代码分析
- 系统 MUST 作为"指挥官"角色，主动地、分阶段地调度 AI 编程工具完成分析任务
- 系统 MUST 采用最高效的策略进行 AI 调度（如：先整体后局部、先结构后细节、并行分析等）
- 关键任务（项目模块划分、功能命名、语义理解）MUST 完全委托给 AI，而非依赖静态规则

**AI 驱动策略**：
- **分阶段驱动**: 将复杂分析拆解为多个阶段（如：结构识别 → 功能语义分析 → 执行流程推理 → 并发模式识别），每阶段使用专门的 Prompt 驱动 AI
- **上下文注入**: 每次驱动 AI 时，注入必要的项目上下文、前序分析结果和当前阶段目标
- **质量验证**: 对 AI 返回的分析结果进行格式验证、完整性检查和一致性校验
- **迭代精炼**: 对不满足要求的 AI 分析结果，自动生成精炼 Prompt 要求 AI 重新分析

**Prompt 指令集要求**：
- 核心指令集 MUST 版本化管理，支持根据不同语言、框架定制
- 每个 Prompt 模板 MUST 包含：目标说明、输入格式、输出格式、质量标准、示例
- Prompt MUST 经过实证验证，确保在主流 AI 模型上的稳定表现（准确率、一致性）
- 系统 MUST 支持用户扩展和定制 Prompt 指令集

**架构影响**：
- 核心可视化引擎与 AI 调度策略层必须清晰分离
- AI 调度策略必须可配置、可优化、可监控（记录每次 AI 调用的输入输出、耗时、token 消耗）
- 支持"分析缓存"：相同代码的 AI 分析结果可复用，避免重复调用
- 支持"增量分析"：代码变更时，仅对变更部分驱动 AI 重新分析

**理由**：静态代码解析（AST、CFG）只能提供语法结构，无法理解代码的语义和意图。AI 是当前唯一能够理解代码业务逻辑、生成自然语言功能描述的技术。通过精心设计的 Prompt 指令集主动驱动 AI，可以获得远超静态分析的深度理解。作为"指挥官"而非"分析者"，工具能够专注于策略优化和结果可视化，将复杂的语义理解完全委托给最擅长的 AI。

### II. Open Connectivity (Platform Core) - MANDATORY

本工具是一个"无外壳"的 MCP (Model Context Protocol) Tool，不依赖任何特定的 AI 模型，必须作为消费 AI 分析结果并进行可视化的中立平台。

**核心要求**：
- 系统 MUST 通过标准化适配器接口 (Adapter Interface) 接入并消费来自多种 AI 编程工具的分析结果
- 系统 MUST 保持 AI 模型中立性，不绑定任何特定 AI 提供商（OpenAI, Anthropic, Google, etc.）
- 适配器 MUST 支持可插拔架构，允许动态添加新的 AI 工具分析源
- 所有 AI 工具接入 MUST 遵循统一的标准化协议和数据格式

**架构影响**：
- 核心可视化引擎与 AI 分析数据消费层必须通过清晰的接口分离
- AI 适配器层必须独立可测试，适配器故障不影响核心可视化功能
- 支持离线模式：可基于预生成的 AI 分析结果文件独立运行
- 数据格式必须版本化，确保向后兼容

**理由**：作为开放平台和中立枢纽，工具的价值在于连接多样化的 AI 分析能力与统一的可视化体验。绑定特定 AI 模型将限制用户选择和工具的长期演进能力。标准化适配器接口确保生态系统的互操作性和可扩展性。

### III. Intelligent Layering & Behavior-Driven Interaction (Visual & Interaction Core) - MANDATORY

"代码整体结构图"必须是可交互的动态层级结构，AI 负责识别代码的逻辑分组，每个具备独立业务功能的代码单元都必须附带专属的、由 AI 命名的启动按钮。

**动态层级要求**：
- 系统 MUST 支持至少 3 个抽象层次：系统级 → 模块级 → 函数级
- AI MUST 基于代码语义自动识别逻辑分组（流程、模块组、功能集）
- 用户 MUST 能够自由展开/折叠任意层级，在宏观架构与微观模块之间无缝导航
- 层级转换 MUST 保持视觉连贯性和上下文清晰度

**行为驱动要求**：
- 图上每一个由 AI 识别出的、具备独立业务功能的代码单元 MUST 附带一个专属的启动按钮
- 启动按钮的名称 MUST 由 AI 根据该代码的功能目的自动生成（如："处理用户登录"、"计算订单总额"）
- 按钮命名 MUST 使用自然语言，清晰描述业务行为而非技术实现
- 无论代码单元是简单函数还是复杂模块组，只要其具备独立功能语义，就 MUST 提供启动按钮

**AI 分析职责**：
- 识别高内聚的代码模块和独立功能单元
- 为每个功能单元生成符合其业务语义的自然语言名称
- 标识跨模块的数据流、控制流和依赖关系
- 生成层级元数据，包括模块命名、关系类型、功能描述

**交互设计要求**：
- 双击节点展开下一层级，显示内部组件和子模块
- 单击启动按钮触发该功能单元的执行可视化
- 面包屑导航显示当前所在层级路径
- 缩放/平移支持自由探索大型代码结构
- 层级过渡动画时长 < 300ms

**理由**：复杂软件系统无法在单一抽象层次被理解。智能分层允许用户从宏观架构逐步深入到具体实现。行为驱动设计将"代码结构"与"执行行为"统一，用户通过点击业务功能按钮来理解代码如何协同运行，符合以业务目标为中心的认知模式。

### IV. Behavior Nesting (Interaction Core) - MANDATORY

启动按钮本身存在层级关系，"大模块"上的"大按钮"可以启动宏观联动场景，展开后内部的子模块拥有各自的"小按钮"，可独立启动子流程。

**嵌套行为架构**：
- 大模块的启动按钮 MUST 能够触发涉及多个子流程的宏观联动执行场景
- 当用户展开大模块后，系统 MUST 显示其内部子模块的独立启动按钮
- 子模块的启动按钮 MUST 能够独立触发其自身的子流程执行
- 系统 MUST 支持任意深度的行为嵌套（受限于代码实际层级）

**层级执行联动**：
- 当启动大模块的"大按钮"时，系统 MUST 自动协调并可视化所有涉及的子流程联动
- 用户 MUST 能够在宏观执行过程中"钻入"特定子模块，查看其内部详细执行
- 从子模块视角启动时，系统 MUST 提供"孤立模式"（仅该子模块）和"上下文模式"（显示上级调用链）
- 执行状态 MUST 在所有层级间保持一致和同步

**交互规则**：
- 用户点击大按钮 → 触发宏观联动场景 → 可实时钻入任意子模块观察细节
- 用户展开模块 → 看到子按钮 → 可单独点击子按钮启动子流程
- 从子流程视角 MUST 能够"向上追溯"到完整调用链
- 系统 MUST 提供视觉指示器标识当前执行所处的层级深度

**AI 分析职责**：
- 识别代码单元之间的调用关系和依赖层级
- 为宏观功能生成完整的子流程调用图
- 标识哪些子功能可以独立执行，哪些依赖上级上下文
- 生成执行场景的元数据（入口参数、预期输出、涉及的子流程）

**理由**：真实软件系统的行为是层级嵌套的。一个"处理订单"的大功能内部包含"验证库存"、"计算价格"、"扣减库存"等子功能。行为可嵌套原则允许用户在任意抽象层次启动和观察执行，既能看到整体协同，又能钻入细节分析，真正理解复杂系统如何"分层、协同运行"。

### V. Concurrency Visualization (Analysis Core) - MANDATORY

必须能够通过时序图、带分叉/汇合的流程图以及在主结构图上进行多流程联动动画，来精准地可视化并行、异步等并发行为。

**并发可视化要求**：
- 系统 MUST 提供时序图 (Sequence Diagram) 视图，清晰展示不同执行线程/协程的时间先后关系
- 系统 MUST 提供带分叉/汇合的流程图，精确表达并行分支、同步点、Join 操作
- 系统 MUST 在主结构图上通过多流程联动动画，实时展示并发执行的多个代码单元
- 系统 MUST 区分并可视化：并行 (Parallel)、并发 (Concurrent)、异步 (Async)、同步等待 (Sync Wait)

**并发语义表达**：
- **并行执行**: 多个流程在时间轴上真正同时推进，使用多个动画指示器同步移动
- **异步调用**: 主流程发起异步任务后立即继续，异步任务独立执行，用分叉箭头表示
- **同步等待**: 主流程阻塞等待某个操作完成，用暂停指示器和等待动画表示
- **汇合点**: 多个并行/异步流程在某个点汇合，用汇聚箭头和同步栅栏表示

**时序图规范**：
- 垂直轴表示时间推进（从上到下）
- 水平方向排列不同的执行实体（线程、服务、组件）
- 消息传递用箭头表示，区分同步调用（实线）和异步消息（虚线）
- MUST 标注关键时间点和等待时长

**流程图规范**：
- 使用菱形表示条件分支，清晰标注分支条件
- 使用并行网关 (Fork/Join) 表示并发分叉和汇合
- 使用不同颜色区分不同的并发流
- MUST 标注同步点和数据依赖

**主结构图动画**：
- 多个流程同时执行时，MUST 在相应的代码单元上显示多个活动指示器
- 指示器 MUST 使用不同颜色或标识区分不同的执行流
- 当流程在不同层级间跳转时，动画 MUST 保持连贯性
- MUST 提供"暂停全部"和"暂停单个流"的控制

**AI 分析职责**：
- 识别代码中的并发模式（多线程、协程、异步 I/O、消息队列）
- 分析并发流之间的同步依赖和数据竞争
- 生成时序图和流程图的元数据
- 标识关键的同步点和潜在的并发问题

**理由**：现代软件系统广泛使用并发来提升性能和响应能力。并发行为的理解是最困难的，因为它涉及时间维度的复杂交织。精准的并发可视化是理解复杂系统运行机制的关键能力，必须作为核心原则而非可选特性。

### VI. User Complete Control (Experience Core) - MANDATORY

用户可以控制任何层级行为的播放、暂停、时间回溯和单步钻取，并能在任何时刻钻取进入"单步运行详情"视图，对变量状态进行深度检查。

**时间控制**：
- 用户 MUST 能够控制任意层级（大模块、小模块、单个函数）执行的播放/暂停
- 用户 MUST 能够在任意执行点进行时间回溯（向前/向后单步，跳转到任意时刻）
- 系统 MUST 支持调节播放速度（0.1x 慢速教学模式 到 10x 快速浏览模式）
- 用户 MUST 能够设置断点，自动暂停到指定的代码单元或事件

**层级钻取控制**：
- 在宏观执行过程中，用户 MUST 能够随时"钻入"任意子模块查看其内部详细执行
- 在子模块执行过程中，用户 MUST 能够"向上追溯"到完整调用链和上级上下文
- 钻取操作 MUST 不中断执行状态，用户可在任意深度暂停和恢复
- 系统 MUST 提供"聚焦模式"：暂时隐藏其他模块，专注于当前关注的执行路径

**单步运行详情视图 (Step-by-Step Detail View)**：
- 用户 MUST 能够在任何时刻从"主结构图"钻取进入"单步运行详情"视图
- 单步详情视图 MUST 显示当前执行点的完整上下文：
  - 当前代码行的源代码和语法高亮
  - 当前作用域内的所有变量及其值
  - 完整的调用栈（函数调用链）
  - 内存状态快照（对象、数组、堆栈）
- 在单步详情视图中，用户 MUST 能够：
  - 逐行单步执行（Step Into / Step Over / Step Out）
  - 检查和修改变量值（用于假设分析）
  - 查看变量的历史变化轨迹
  - 设置条件断点（变量值满足条件时暂停）
- 单步详情视图与主结构图 MUST 保持双向同步：
  - 在详情视图中步进时，主结构图同步高亮当前执行位置
  - 从主结构图跳转时，详情视图立即定位到对应代码行

**状态检查**：
- 用户 MUST 能够检查任意执行点的所有变量值、对象状态、内存快照
- 系统 MUST 展示完整的调用栈和返回路径
- 用户 MUST 能够比较不同执行点或不同分支的状态差异
- 复杂数据结构（对象、数组、树、图）MUST 支持展开查看和可视化呈现

**并发流控制**：
- 用户 MUST 能够独立控制每个并发流的播放/暂停
- 用户 MUST 能够"对齐时间轴"：将多个并发流调整到相同的时间点进行对比
- 系统 MUST 支持"单流聚焦"：暂时隐藏其他并发流，专注于单一流的执行
- 用户 MUST 能够标记和保存感兴趣的并发执行片段

**非线性探索**：
- 用户 MUST 能够进行"假设分析"：修改某个状态或变量，观察后续执行的变化
- 系统 MUST 支持"多路径对比"：同时可视化不同条件分支或不同输入的执行结果
- 用户 MUST 能够创建"执行书签"：保存特定的执行状态和视角，便于重复访问
- 系统 MUST 提供全局搜索功能：快速定位特定的函数调用、变量修改或事件发生

**禁止被动模式**：
- 不得提供只播放不控制的"视频模式"
- 不得限制用户访问任何层级的执行历史
- 不得隐藏或简化任何状态信息以"降低复杂度"（应提供可选的简化视图，但默认完整）
- 不得限制用户的钻取深度或探索范围

**理由**：理解和学习需要主动探索和反复实验，而非被动观看。完全的用户控制是工具教育和调试价值的核心。单步运行详情视图提供了传统调试器的深度检查能力，与宏观的结构图和动画可视化形成互补，用户既能看到"森林"（整体协同），又能看到"树木"（每行代码的执行细节），真正实现从宏观到微观的无缝探索。

## Architecture Constraints

### MCP Integration Requirements

- 系统 MUST 实现标准 MCP Tool 接口，作为 AI 分析结果的消费者
- 系统 MUST 内置 AI 调度引擎，主动驱动外部 AI 工具进行分阶段分析
- 适配器 MUST 支持以下 AI 工具分析源：
  - IDE 集成 AI 工具（VS Code Copilot, JetBrains AI, etc.）
  - 命令行 AI 工具（Claude Code, Cursor, Aider, etc.）
  - 云端 AI 服务（OpenAI Code Interpreter, Anthropic, Google Gemini, etc.）
  - 本地 AI 模型（Ollama, LM Studio, etc.）
- 标准化数据格式 MUST 包含：
  - `code_structure`: 代码层级结构、逻辑分组、功能单元元数据
  - `behavior_metadata`: 启动按钮命名、功能描述、执行场景定义
  - `execution_trace`: 执行路径、状态快照、时间序列数据
  - `concurrency_info`: 并发流识别、同步点、依赖关系
  - `prompt_templates`: AI 驱动的核心指令集模板
- 适配器错误 MUST 优雅降级，不影响核心可视化功能（使用缓存或降级模式）

### Technology Stack

- **前端可视化**：支持 Web (优先) 和桌面应用（Tauri 优于 Electron，性能和资源考虑）
- **图形渲染引擎**：
  - 结构图：D3.js (力导向图)、Cytoscape.js (大型图)、vis.js (网络图)
  - 时序图：PlantUML-like 自定义渲染、Mermaid.js 集成
  - 流程图：BPMN.js、joint.js
  - 动画引擎：Canvas + requestAnimationFrame (性能优先)
  - 代码编辑器：Monaco Editor (VS Code 内核，支持语法高亮、断点、变量提示)
- **AI 接口层**：JSON Schema 定义的数据格式，支持 Protocol Buffers 序列化（性能优化）
- **AI 调度引擎**：
  - Prompt 模板管理：版本化、语言特定、可扩展
  - 调度策略引擎：分阶段执行、并行调度、结果验证、迭代精炼
  - 调用监控：输入输出日志、耗时统计、token 消耗追踪
- **数据存储**：
  - 执行追踪数据：IndexedDB (Web) / SQLite (Desktop)
  - AI 分析缓存：本地文件系统 + LRU 淘汰策略
  - Prompt 模板库：Git 版本管理 + 热加载
  - 用户偏好和书签：LocalStorage + 云端同步（可选）
- **语言支持**：优先支持 Python, JavaScript/TypeScript, Java, Go, Rust（后续扩展）

### Performance Standards

**渲染性能**：
- **小型项目** (<500 节点)：首次渲染 <1 秒，层级切换 <150ms
- **中型项目** (500-2000 节点)：首次渲染 <3 秒，层级切换 <300ms
- **大型项目** (2000-5000 节点)：首次渲染 <8 秒，层级切换 <500ms
- **超大项目** (>5000 节点)：支持渐进式加载和虚拟化渲染，初始可见区域 <2 秒

**交互响应**：
- **关键交互** (点击按钮、暂停/播放)：响应延迟 <100ms（P95），<200ms（P99）
- **次要交互** (展开节点、切换视图)：响应延迟 <300ms（P95），<500ms（P99）
- **复杂操作** (钻取详情、时间回溯)：响应延迟 <500ms（P95），<1s（P99）

**动画性能**：
- **并发流数量**：流畅支持 ≤5 个并发流（≥30 FPS），降级支持 ≤10 个（≥15 FPS）
- **动画帧率**：关键交互动画 ≥30 FPS，复杂场景允许降至 ≥15 FPS
- **状态更新**：单步执行状态更新 <150ms，批量状态更新 <300ms

**AI 调度性能**（深度语义分析需要充足时间）：
- **单次 AI 调用**：目标 <30 秒（P50），<60 秒（P95），超时限制 120 秒
- **小型项目** (<1000 LOC)：
  - 完整分析 2-5 分钟（结构识别 + 功能语义分析 + 执行流程推理）
  - 增量分析 30-60 秒（局部变更的语义理解）
- **中型项目** (1000-5000 LOC)：
  - 完整分析 10-20 分钟（多阶段深度分析 + 模块关系推理）
  - 增量分析 2-5 分钟（变更影响分析 + 关联模块更新）
- **大型项目** (5000-20000 LOC)：
  - 完整分析 30-60 分钟（分模块并行分析 + 全局整合）
  - 增量分析 5-15 分钟（变更传播分析 + 依赖链更新）
- **超大项目** (>20000 LOC)：
  - 完整分析 1-3 小时（分批后台处理，优先分析核心模块）
  - 增量分析 10-30 分钟（智能范围限定 + 缓存复用）
  - 支持断点续传和进度可视化

**数据处理性能**：
- **数据加载**：小型 (<1MB) <500ms，中型 (1-10MB) <2 秒，大型 (>10MB) <5 秒
- **索引建立**：小型项目 <1 秒，中型项目 <5 秒，大型项目 <15 秒
- **缓存命中率**：AI 分析结果 ≥70%，结构图数据 ≥80%

**内存占用** (目标值，允许动态调整)：
- **基础运行时**：≤100MB (空项目状态)
- **中型项目**：≤500MB (包含结构图、执行追踪、AI 缓存)
- **大型项目**：≤1GB (启用分页和虚拟化)
- **超大项目**：≤2GB (完整功能) 或启用轻量模式 (≤500MB，部分功能降级)

## Quality Standards

### AI Analysis Quality

- **功能识别准确性**：AI 识别的独立功能单元与人类专家评估一致性 ≥85%
- **按钮命名质量**：自动生成的启动按钮名称清晰度和业务相关性评分 ≥4.0/5.0（用户评分）
- **分层合理性**：AI 生成的模块分组与代码逻辑内聚性的相关度 ≥0.8（统计指标）
- **并发识别完整性**：并发模式识别的召回率 ≥90%，精确率 ≥85%
- **Prompt 有效性**：核心指令集在主流 AI 模型上的稳定表现率 ≥95%（重复执行结果一致性）
- **可解释性**：每个 AI 决策（功能识别、命名、分组）必须附带解释信息和置信度
- **鲁棒性**：对不完整或含错误的代码，系统必须生成尽力而为的分析，标注不确定区域
- **一致性**：相同代码的重复分析结果必须完全一致（确定性输出或明确标注非确定性因素）

### User Experience

- **学习曲线**：新用户必须在 15 分钟内掌握基本交互（层级导航、启动按钮、播放控制、详情视图钻取）
- **认知负荷**：单个视图顶层节点数量应控制在 7±2 个（Miller's Law），支持按需展开
- **视觉清晰度**：
  - 符合 WCAG 2.1 AA 无障碍标准（色彩对比、字体大小）
  - 并发流使用可区分的颜色方案（支持色盲友好模式）
  - 动画流畅度 ≥30 FPS，关键交互 ≥60 FPS
- **错误处理**：
  - AI 分析数据缺失或损坏时，提供降级模式和明确的用户提示
  - AI 调用超时或失败时，提供重试选项和备用方案
  - 执行追踪数据不完整时，标注缺失区域但不阻塞其他功能
  - 并发可视化失败时，回退到简化的线性视图

### Code Quality

- **测试覆盖率**：
  - 核心可视化逻辑 ≥90%
  - AI 适配器层 ≥85%
  - AI 调度引擎 ≥85%
  - 并发渲染引擎 ≥80%（复杂度高）
  - Prompt 模板验证 ≥80%
- **模块化**：
  - 结构图引擎、行为启动系统、并发可视化模块、单步详情视图必须独立可测试
  - AI 调度引擎与可视化引擎必须完全解耦
  - AI 适配器必须可插拔，新增适配器不修改核心代码
- **文档完整性**：
  - 所有公开 API 和数据格式必须有完整文档和示例
  - AI 分析数据的 JSON Schema 必须版本化和文档化
  - Prompt 模板库必须有使用指南和最佳实践
  - 用户交互手册和最佳实践指南
- **可扩展性**：
  - 添加新语言支持仅需实现语言特定的 AI 适配器和 Prompt 模板
  - 添加新的可视化视图（如 3D 结构图）不应修改核心架构
  - 支持插件系统，允许第三方扩展可视化能力和 Prompt 指令集

## Governance

### Amendment Process

1. **提案**：任何团队成员可以通过书面文档提出宪章修订提案
2. **审查**：修订提案必须经过至少 2 名技术负责人和 1 名用户代表审查
3. **影响分析**：评估对现有功能、模板、用户工作流和生态系统的影响
4. **批准**：需要项目领导团队达成共识（≥75% 同意）
5. **迁移计划**：破坏性变更需要记录迁移路径、时间表和向后兼容策略

### Versioning Policy

- **版本格式**：MAJOR.MINOR.PATCH（语义化版本 2.0）
- **MAJOR 递增**：移除或重新定义核心原则，破坏性架构变更，不兼容的数据格式变更
- **MINOR 递增**：新增原则、新增强制性章节、扩展功能范围、兼容的数据格式扩展
- **PATCH 递增**：澄清说明、措辞改进、非语义精炼、性能优化

### Compliance Review

- **频率**：所有功能规格和实施计划必须引用相关宪章原则
- **验证**：使用 `.specify/templates/plan-template.md` 中的 Constitution Check 章节验证合规性
- **上报**：违规必须在 Complexity Tracking 章节中说明理由或提出宪章修订
- **审计追踪**：所有宪章决策必须记录在功能规格和 ADR（架构决策记录）中
- **自动化检查**：CI/CD 流程应包含宪章合规性自动检查（如 AI 数据格式验证、Prompt 模板验证）

### Living Document

本宪章在发生冲突时优先于所有其他项目文档。团队在以下操作前必须验证合规性：
- 创建功能规格（`/speckit.specify`）
- 生成实施计划（`/speckit.plan`）
- 开始实施任务（`/speckit.implement`）

当出现违反原则的复杂性或例外情况时，团队必须：
1. 简化方法以符合原则，或
2. 在功能计划中记录理由并提供详细的成本收益分析，如果模式反复出现则提出宪章修订

### Backward Compatibility

- **数据格式兼容性**：AI 分析数据格式变更必须向后兼容至少 2 个 MAJOR 版本
- **Prompt 模板兼容性**：核心指令集格式变更必须向后兼容至少 1 个 MAJOR 版本
- **API 稳定性**：公开 API 的破坏性变更必须提供至少 6 个月的弃用期和迁移指南
- **用户体验连续性**：交互模式的重大变更必须提供传统模式选项或渐进式迁移路径

**Version**: 2.1.0 | **Ratified**: 2025-10-09 | **Last Amended**: 2025-10-09
